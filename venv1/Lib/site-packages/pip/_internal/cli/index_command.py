"""
Command mixins for handling network/index-based operations.
"""

from __future__ import annotations

import logging
import os
import sys
from functools import lru_cache
from optparse import Values
from typing import TYPE_CHECKING

from pip._vendor import certifi
from pip._internal.cli.base_command import Command
from pip._internal.cli.command_context import CommandContextMixIn

if TYPE_CHECKING:
    from ssl import SSLContext
    from pip._internal.network.session import PipSession

logger = logging.getLogger(__name__)


@lru_cache
def _create_truststore_ssl_context() -> SSLContext | None:
    """Create SSL context using truststore if supported."""
    if sys.version_info < (3, 10):
        logger.debug("Truststore requires Python 3.10+")
        return None

    try:
        import ssl
        from pip._vendor import truststore
    except ImportError:
        logger.debug("Truststore not available on this platform")
        return None

    ctx = truststore.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    ctx.load_verify_locations(certifi.where())
    return ctx


class SessionCommandMixin(CommandContextMixIn):
    """
    Mixin for commands requiring a network session.
    """

    def __init__(self) -> None:
        super().__init__()
        self._session: PipSession | None = None

    @classmethod
    def _get_index_urls(cls, options: Values) -> list[str] | None:
        """Extract index URLs from CLI options."""
        urls: list[str] = []

        if not getattr(options, "no_index", False):
            index_url = getattr(options, "index_url", None)
            if index_url:
                urls.append(index_url)

        extra_urls = getattr(options, "extra_index_urls", None)
        if extra_urls:
            urls.extend(extra_urls)

        return urls or None

    def get_default_session(self, options: Values) -> PipSession:
        """Return cached or newly created session."""
        if self._session is None:
            self._session = self.enter_context(self._build_session(options))
        return self._session

    def _build_session(
        self,
        options: Values,
        retries: int | None = None,
        timeout: int | None = None,
    ) -> PipSession:
        from pip._internal.network.session import PipSession

        cache_dir = options.cache_dir
        if cache_dir and not os.path.isabs(cache_dir):
            raise ValueError("Cache directory must be an absolute path")

        ssl_context = None
        if "legacy-certs" not in options.deprecated_features_enabled:
            ssl_context = _create_truststore_ssl_context()

        session = PipSession(
            cache=os.path.join(cache_dir, "http-v2") if cache_dir else None,
            retries=retries if retries is not None else options.retries,
            trusted_hosts=options.trusted_hosts,
            index_urls=self._get_index_urls(options),
            ssl_context=ssl_context,
        )

        if options.cert:
            session.verify = options.cert

        if options.client_cert:
            session.cert = options.client_cert

        if timeout is not None or options.timeout:
            session.timeout = timeout if timeout is not None else options.timeout

        if options.proxy:
            session.proxies = {
                "http": options.proxy,
                "https": options.proxy,
            }
            session.trust_env = False
            session.pip_proxy = options.proxy

        session.auth.prompting = not options.no_input
        session.auth.keyring_provider = options.keyring_provider

        return session


def _pip_self_version_check(session: PipSession, options: Values) -> None:
    from pip._internal.self_outdated_check import pip_self_version_check
    pip_self_version_check(session, options)


class IndexGroupCommand(Command, SessionCommandMixin):
    """
    Base class for commands supporting index-related options.
    """

    def handle_pip_version_check(self, options: Values) -> None:
        if getattr(options, "disable_pip_version_check", False) or getattr(options, "no_index", False):
            return

        try:
            session = self._build_session(
                options,
                retries=0,
                timeout=min(5, options.timeout),
            )
            with session:
                _pip_self_version_check(session, options)
        except Exception:
            logger.warning("Error occurred while checking latest version.")
            logger.debug("Detailed error:", exc_info=True)